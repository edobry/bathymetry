<!DOCTYPE HTML>
<html>
    <head>
        <title>transects</title>

        <link href="../node_modules/c3/c3.css" rel="stylesheet">
        <script
            src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous"></script>
        <script src="https://d3js.org/d3.v3.min.js"></script>
        <script src="../node_modules/c3/c3.js"></script>
        <script src="../node_modules/chroma-js/chroma.min.js"></script>
        <style type="text/css">
            .c3-target-floor .c3-areas-floor path {
                opacity: 1 !important;
                fill: rgb(126, 125, 106) !important;
            }

            .c3-target-floor .c3-circles-floor circle {
                fill: rgb(196, 195, 166) !important;
            }

            .c3-target-floor .c3-lines-floor path {
                stroke: rgb(196, 195, 166) !important;
            }

            .c3-chart-line .c3-circle {
                fill: rgb(7, 6, 59) !important;
            }

            .c3-chart-line .c3-circle-0,
            .c3-target-floor .c3-circle {
                visibility: hidden !important;
            }

            .c3-chart-line .c3-circle-0 {
                visibility: hidden !important;
            }
        </style>
    </head>
    <body>
        <div id="chart"></div>

        <script type="text/javascript">
            const byField = field => (a, b) =>
                a[field] - b[field];

            const byFieldDesc = field => (a, b) =>
                b[field] - a[field];

            fetch("./transect1.json", { method: "get" })
                .then(response =>
                    response.json())
                .then(data => {
                    return drawChart(data);
                })
                .catch(err => {
                    throw new Error(err);
                });

            const drawChart = ({ bands, floor, maxDepth }) => {
                const bandRows = Object.entries(bands)
                    .sort(([a], [b]) =>
                        parseFloat(b) - parseFloat(a))
                    .map(([name, points]) => [
                        name, ...Object.entries(points)
                            .map(([dist, depth]) =>
                                depth)
                    ]);

                const bandNames = bandRows.map(([name]) => name);

                const entriesToMap = (map, [key, value]) => {
                    map[key] = value;
                    return map;
                };

                const colorScale = chroma.scale(['#1e489c','#de4132'])
                    .mode('lch').colors(bandRows.length);

                const xVals = Object.keys(floor).map(parseFloat);
                const stationX = Object.keys(Object.values(bands)[0])
                    .map(parseFloat)
                    .sort();

                const floorVals = Object.values(floor)
                    .filter(depth => depth < maxDepth)
                    .map(x => maxDepth-x);

                const config = {
                    bindto: "#chart",
                    size: {
                        height: 500
                    },
                    data: {
                        xs: [
                            ["floor", "x"],
                            ...bandNames.map(band => [band, "stationX"])
                        ].reduce(entriesToMap, {}),
                        columns: [
                            ["x", ...xVals],
                            ["stationX", ...stationX],
                            ...bandRows,
                            ["floor", ...floorVals]
                        ],
                        // order: false,
                        order: bandNames,
                        // "line", "spline", "step", "area", "area-step" are also available to stack
                        types: [
                            ["floor", "area"],
                            ...bandNames.map(name => [name, "area"])
                        ].reduce(entriesToMap, {}),
                        groups: [[...bandNames]],
                        color: (color, d) => {
                            const id = typeof d == "object"
                                ? d.id
                                : d;

                            const thing = {
                                floor: "#7e7d6a"
                            }[id] || colorScale[bandNames.indexOf(id)];

                            return thing;
                        }


                    },
                    // area: {
                    //     zerobased: false
                    // },
                    axis: {
                        y: {
                            // inverted: true
                            tick: {
                                format: d =>
                                    parseInt(d)-maxDepth
                            }

                        }
                    }
                };

                console.log(config);
                console.log(config.data.columns.map(col => col[0]));

                var chart = c3.generate(config);
            };
        </script>
    </body>
</html>
